#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals

from grako.buffering import Buffer
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS, generic_main  # noqa


__all__ = [
    'cl1ckParser',
    'cl1ckSemantics',
    'main'
]

KEYWORDS = {}


class cl1ckBuffer(Buffer):
    def __init__(
        self,
        text,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='#.*?$',
        ignorecase=None,
        namechars='',
        **kwargs
    ):
        super(cl1ckBuffer, self).__init__(
            text,
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            namechars=namechars,
            **kwargs
        )


class cl1ckParser(Parser):
    def __init__(
        self,
        whitespace=None,
        nameguard=None,
        comments_re=None,
        eol_comments_re='#.*?$',
        ignorecase=None,
        left_recursion=False,
        parseinfo=True,
        keywords=None,
        namechars='',
        buffer_class=cl1ckBuffer,
        **kwargs
    ):
        if keywords is None:
            keywords = KEYWORDS
        super(cl1ckParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=comments_re,
            eol_comments_re=eol_comments_re,
            ignorecase=ignorecase,
            left_recursion=left_recursion,
            parseinfo=parseinfo,
            keywords=keywords,
            namechars=namechars,
            buffer_class=buffer_class,
            **kwargs
        )

    @graken()
    def _program_(self):
        self._header_()
        self.name_last_node('header')
        self._declarations_()
        self.name_last_node('declarations')
        self._equations_()
        self.name_last_node('equations')
        self._check_eof()
        self.ast._define(
            ['declarations', 'equations', 'header'],
            []
        )

    @graken()
    def _header_(self):
        self._token('program')
        self._id_()
        self.name_last_node('name')
        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _declarations_(self):

        def block0():
            self._declaration_()
            self.add_last_node_to_name('@')
        self._closure(block0)

    @graken()
    def _equations_(self):

        def block0():
            self._equation_()
            self.add_last_node_to_name('@')
        self._closure(block0)

    @graken()
    def _declaration_(self):
        with self._choice():
            with self._option():
                with self._group():
                    self._token('Scalar')
                    self.name_last_node('vartype')
                    self._id_()
                    self.name_last_node('name')
                    self._token('<')
                    self._io_()
                    self.name_last_node('iotype')
                    self._token('>')
                    self._token(';')
            with self._option():
                with self._group():
                    self._token('Vector')
                    self.name_last_node('vartype')
                    self._id_()
                    self.name_last_node('name')
                    self._dim_vector_()
                    self.name_last_node('dims')
                    self._token('<')
                    self._io_()
                    self.name_last_node('iotype')
                    with self._optional():
                        self._token(',')
                        self._ow_()
                        self.name_last_node('ow')
                    self._token('>')
                    self._token(';')
            with self._option():
                with self._group():
                    self._token('Matrix')
                    self.name_last_node('vartype')
                    self._id_()
                    self.name_last_node('name')
                    self._dim_matrix_()
                    self.name_last_node('dims')
                    self._token('<')
                    self._io_()
                    self.name_last_node('iotype')

                    def block12():
                        self._token(',')
                        self._prop_()
                        self.add_last_node_to_name('props')
                    self._closure(block12)
                    with self._optional():
                        self._token(',')
                        self._ow_()
                        self.name_last_node('ow')
                    self._token('>')
                    self._token(';')
            self._error('no available options')
        self.ast._define(
            ['dims', 'iotype', 'name', 'ow', 'vartype'],
            ['props']
        )

    @graken()
    def _equation_(self):
        self._expression_()
        self.name_last_node('lhs')
        self._token('=')
        self._expression_()
        self.name_last_node('rhs')
        self._token(';')
        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _dim_vector_(self):
        self._token('(')
        self._id_()
        self.add_last_node_to_name('@')
        self._token(')')

    @graken()
    def _dim_matrix_(self):
        self._token('(')
        self._id_()
        self.add_last_node_to_name('@')
        self._token(',')
        self._id_()
        self.add_last_node_to_name('@')
        self._token(')')

    @graken()
    def _io_(self):
        with self._choice():
            with self._option():
                self._token('Input')
            with self._option():
                self._token('Output')
            self._error('expecting one of: Input Output')

    @graken()
    def _prop_(self):
        with self._choice():
            with self._option():
                self._token('Square')
                self.name_last_node('@')
            with self._option():
                self._token('Rectangular')
                self.name_last_node('@')
            with self._option():
                self._token('Diagonal')
                self.name_last_node('@')
            with self._option():
                self._token('LowerTriangular')
                self.name_last_node('@')
            with self._option():
                self._token('UpperTriangular')
                self.name_last_node('@')
            with self._option():
                self._token('UnitDiagonal')
                self.name_last_node('@')
            with self._option():
                self._token('ImplicitUnitDiagonal')
                self.name_last_node('@')
            with self._option():
                self._token('Symmetric')
                self.name_last_node('@')
            with self._option():
                self._token('Non-singular')
                self.name_last_node('@')
            with self._option():
                self._token('SPD')
                self.name_last_node('@')
            with self._option():
                self._token('LowerStorage')
                self.name_last_node('@')
            with self._option():
                self._token('UpperStorage')
                self.name_last_node('@')
            self._error('expecting one of: Diagonal ImplicitUnitDiagonal LowerStorage LowerTriangular Non-singular Rectangular SPD Square Symmetric UnitDiagonal UpperStorage UpperTriangular')

    @graken()
    def _ow_(self):
        self._token('overwrites')
        self._token('(')
        self._id_()
        self.name_last_node('@')
        self._token(')')

    @graken()
    def _expression_(self):
        with self._choice():
            with self._option():
                self._term_()
                self.name_last_node('args')

                def block1():
                    with self._group():
                        with self._choice():
                            with self._option():
                                self._token('+')
                            with self._option():
                                self._token('-')
                            self._error('expecting one of: + -')
                    self.add_last_node_to_name('ops')
                    self._term_()
                    self.name_last_node('args')
                self._positive_closure(block1)
            with self._option():
                self._term_()
                self.name_last_node('@')
            self._error('no available options')
        self.ast._define(
            ['args'],
            ['ops']
        )

    @graken()
    def _term_(self):
        with self._choice():
            with self._option():
                self._token('-')
                self.add_last_node_to_name('ops')
                self._term_()
                self.add_last_node_to_name('args')
            with self._option():
                self._factor_()
                self.name_last_node('args')

                def block3():
                    self._token('*')
                    self.add_last_node_to_name('ops')
                    self._factor_()
                    self.name_last_node('args')
                self._positive_closure(block3)
            with self._option():
                self._factor_()
                self.name_last_node('@')
            self._error('no available options')
        self.ast._define(
            [],
            ['args', 'ops']
        )

    @graken()
    def _factor_(self):
        with self._choice():
            with self._option():
                self._token('(')
                self._expression_()
                self.name_last_node('@')
                self._token(')')
            with self._option():
                self._unary_()
                self.name_last_node('func')
                self._token('(')
                self._expression_()
                self.name_last_node('arg')
                self._token(')')
            with self._option():
                self._id_()
                self.name_last_node('@')
            with self._option():
                self._constant_()
                self.name_last_node('@')
            self._error('no available options')
        self.ast._define(
            ['arg', 'func'],
            []
        )

    @graken()
    def _unary_(self):
        with self._choice():
            with self._option():
                self._token('trans')
            with self._option():
                self._token('inv')
            self._error('expecting one of: inv trans')

    @graken()
    def _id_(self):
        self._pattern(r'[a-zA-Z][a-zA-Z0-9_]*')

    @graken()
    def _constant_(self):
        self._pattern(r'[0-9]+(\.[0-9]+)?([Ee][+-]?[0-9]+)?')


class cl1ckSemantics(object):
    def program(self, ast):
        return ast

    def header(self, ast):
        return ast

    def declarations(self, ast):
        return ast

    def equations(self, ast):
        return ast

    def declaration(self, ast):
        return ast

    def equation(self, ast):
        return ast

    def dim_vector(self, ast):
        return ast

    def dim_matrix(self, ast):
        return ast

    def io(self, ast):
        return ast

    def prop(self, ast):
        return ast

    def ow(self, ast):
        return ast

    def expression(self, ast):
        return ast

    def term(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def unary(self, ast):
        return ast

    def id(self, ast):
        return ast

    def constant(self, ast):
        return ast


def main(filename, startrule, **kwargs):
    with open(filename) as f:
        text = f.read()
    parser = cl1ckParser(parseinfo=False)
    return parser.parse(text, startrule, filename=filename, **kwargs)

if __name__ == '__main__':
    import json
    ast = generic_main(main, cl1ckParser, name='cl1ck')
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

